# 十 shell编程

## 1 基础正则表达式

### 1.1 正则表达式与通配符

- 正则表达式用来在**文件中**匹配符合条件的**字符串**，正则是**包含匹配**。`grep`、`awk`、`sed`等命令可以支持正则表达式
- 通配符涌来了匹配符合条件的**文件名**，通配符是**完全匹配**。`ls`、`find`、`cp`这些命令不支持正则表达式，所以只能使用shell自己的通配符来进行匹配

### 1.2 基础正则表达式

| 元字符    | 作用                                                         |
| --------- | ------------------------------------------------------------ |
| *         | 前一个字符匹配0次或任意多次                                  |
| .         | 匹配除了换行符外任意一个字符                                 |
| ^         | 匹配行首。例如^hello匹配以hello开头的行                      |
| $         | 匹配行尾。例如hello$会匹配以hello结尾的行                    |
| []        | 匹配中括号中指定的任意**一个字符**。例如`[0-9][a-z]`匹配数字和小写字母组成的两个字符 |
| [^]       | 匹配除中括号内字符以外的任意一个**不是换行符**的字符。例如`[^0-9]`匹配任意一个非数字字符 |
| \         | 转义符                                                       |
| `\{n\}`   | 表示其前面的字符恰好出现n次。<br />例如`[0-9]\{4\}`匹配4位数字，`[1][3-8][0-9]\{9\}`匹配手机号码 |
| `\{n,\}`  | 表示其前面的字符出现不小于n次。例如`[0-9]\{2,\}`表示两位及以上的数字 |
| `\{n,m\}` | 表示其前面的字符至少出现n次，最多出现m次。<br />例如`[a-z]\{6,8\}`匹配6-8位小写字母 |

典型的正则表达式：

#### 例子

```shell
# * 前一个字符匹配0次或任意多次

grep "a*" 文件名
#匹配所有内容，包括空白行，没有意义

grep "aa*" 文件名
#匹配至少包含一个a的行

grep "aaa*" 文件名
#匹配至少包含两个a的行
```

```shell
# . 匹配除了换行以外的任意一个字符

grep "s..d" 文件名
#匹配在s和d之间有两个字符的行

grep "s.*d" 文件名
#匹配在s和d之间有任意字符

grep ".*" 文件名
#匹配所有内容
```

```shell
# ^ 匹配行首 $ 匹配行尾

grep "^M" 文件名
#匹配以M开头的行

grep "n$" 文件名
#匹配以n结尾的行

grep -n "^$" 文件名
#匹配空白行，-n显示行号
```

```shell
# [] 匹配中括号中指定的任意一个字符 [^] 匹配除中括号内字符以外的任意一个不是换行符的字符

grep "^[0-9]" 文件名
#匹配以数字开头的行
grep "^[^0-9]" 文件名
#匹配不是以数字开头的行，但不包括空白行
```

```shell
# \ 转义符

grep "\.$" 文件名
#匹配以.结尾的行
```

```shell
# \{n\} 表示其前面的字符恰好出现n次
# \{n,m\} 表示其前面的字符出现大于n次，小于m次

grep "[0-9]\{3\}" 文件名
#匹配含有三个连续数字的行
```

## 2 字符截取命令

### 2.1 cut字段提取命令

```shell
cut [选项] 文件名
	-f 列号	提取第几列
	-d 分隔符	按照指定分隔符分割列

cut -d ":" -f 1,3 /etc/passwd
#提取用户名和UID
```

```shell
#cut命令的局限

df -h | cut -d " " -f 1,3
#cut的分隔符是非常严格的，多个空格作为分隔符就很难区分
```

-   cut适用于严格的分隔符如：`:`、`tab`
-   cut不适用于分隔符为多个空格这样的情况
-   能用cut就用cut，因为相对简单，不易出错

### 2.2 printf命令(awk常用)

printf是格式化输出命令，不算是字符截取命令，但是它常用在`awk`语句中，作为标准输出格式

```shell
printf "输出类型输出格式" 输出内容
输出类型：
	%ns		输出字符串。n是数字代表几个字符
	%ni		输出整数。n是数字代表几个数字
	%m.nf	输出浮点数。m和n是数字，代表输出的整数位数和小数位数。
			如%8.2f代表输出8位浮点数，其中2位小数，6位整数
输出格式：
	\a		警告音
	\b		退格
	\f		清屏
	\n		换行
	\r		回车
	\t		水平制表符
	\v		垂直制表符

例子：
printf %s 1 2 3 4 5 6
1 2 3 4 5 6没有换行

printf %s %s %s 1 2 3 4 5 6
%s %s 1 2 3 4 5 6

printf "%s %s %s" 1 2 3 4 5 6
1 2 34 5 6

printf "%S %S %S \n" 1 2 3 4 5 6
1 2 3
4 5 6

#printf无法使用管道符，只能使用$()内置命令来传递字符数据
printf "输出类型输出格式" $(cat 文件名)
```

-   awk中支持print和printf输出
    -   print会在每个输出后自动加入一个换行符(linux默认没有print命令)
    -   printf是标准格式输出命令，并不会自动加入换行符，如果需要换行需要加入换行符

### 2.3 awk命令

awk命令是较为复杂的命令，在字符截取命令中，能用cut就用cut，cut办不到的事情再考虑用awk

```shell
awk '条件1{动作1} 条件2{动作2} ... ' 文件名
条件：
	一般使用关系表达式作为条件
	x>10		判断变量x是否大于10
	x>=10
	x<=10
动作：
	格式化输出
	流程控制语句

df -h | awk '{printf $1 "\t" $5 "\n"}'
#输出磁盘名和已用空间
df -h | awk '{print $1 "\t" $5}'
```



### 2.4  sed命令

## 3 字符处理命令

## 4 条件判断

## 5 流程控制

