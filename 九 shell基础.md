# 九 shell基础

## 1 shell概述

### 1.1 shell是什么？
- shell是一个**命令解释器**，它把用户发送的字符命令，**翻译**为linux内核可以识别的机器命令，内核根据命令要求去调用硬件运行程序
    - linux内核从硬件获取程序返回的结果传递给shell，shell将它**翻译**为用户可以读懂的字符界面
    - shell其实就是我们的命令行操作界面
    - 用户可以用shell来启动、挂起、停止甚至编写程序
- **shell还是一门功能强大的编程语言**
    - 易编写，易调试，灵活性较强
    - shell是解释执行的脚本语言，在shell中可以直接调用linux命令

### 1.2 shell的分类
- Bourne Shell：最古老，最主流的shell，主文件名sh
    - 主要包括sh、ksh、**Bash**、psh、zsh
- C shell：主要在BSD版的Unix系统中使用，语法与C语言相似而得名
    - 主要包括csh、tcsh
- 两种shell互相不兼容，linux的标准shell是**Bash**

### 1.3 linux支持的shell
- 可以在/etc/shells中查看
```
1 /bin/sh
2 /bin/bash
3 /usr/bin/sh
4 /usr/bin/bash
5 /bin/tcsh
6 /bin/csh
```

- 各种shell之间的切换：
  - 直接键入`sh`：切换为sh
  - `exit`：退回到Bash

## 2 shell脚本的执行方式

### 2.1 echo输出命令

```shell
echo 选项 输出内容
     -e 支持反斜线控制的字符转换
输出内容有空格，就要用双引号""或''
```

#### 反斜线控制的字符转换

控制字符|作用
--------|----
\\\\    |输出\本身
\a      |输出警告音
\b      |退格键
\c      |取消输出行末的换行符。和`-n`选项一致。
\e      |ESCAPE键
\f      |换页符
\n      |换行符
\r      |回车
\t      |制表符，tab
\v      |垂直制表符
\0nnn   |按照八进制ASCll码表输出字符。其中0位数字零，nnn是三位八进制数
\xhh    |按照十六进制ASCll码表输出字符。其中hh是两位十六进制数

**例子**：
- `echo -e "ab\bc"`输出为`ac`
- `echo -e "a\tb\tc\nd\te\tf"`输出为
```
a   b   c
d   e   f
```
- `echo -e "\x61\t\x62\t\x63\n\x64\t\x65\t\x66"`输出为
```
a   b   c
d   e   f
```
- `echo -e "\e[32;40m abcd\e[0m"`
- 输出颜色，绿色黑底的abcd
```
颜色语法

其中F代表字体颜色，B代表的是背景的颜色
其中设置颜色的格式为：\e[F;Bm 显示的字符\e[0m
\e[0m表示结束颜色输出，否则后面的命令行都会沿用前面的配色方案

F	B	颜色
30	40	黑色
31	41	红色
32	42	绿色
33	43	黄色
34	44	蓝色
35	45	紫红色
36	46	青蓝色
37	47	白色
```

### 2.2 第一个shell脚本
- 新建脚本`vim hello.sh`
```bash
#!/bin/bash
#created by: ice-milk
#This is my first shell at 2019.8.2

echo -e 'hello world!\n'
echo -e '\e[30;43m hello world!\e[0m'
```
- `#!/bin/bash`是shell脚本的标注，不能省略
- 写完整的注释，养成良好的注释习惯

### 2.3 运行脚本
- 赋予运行权限`chmod 755 hello.sh`
    - `./hello.sh`直接运行
- 通过bash调用执行脚本
    - `bash hello.sh`

**补充**：
- `cat -A 文件名`可以查看文档中的隐藏字符
- 在linux下编辑的文件的回车符是$
- 而在windows下编辑的文件的回车符是`^M$`
- 这会导致报错
- 解决办法：`dos2lunix 文件名`可以把文件格式转换过来

## 3 bash的基本功能

### 3.1 历史命令与命令补全

#### 历史命令
```bash
history可以查看我们之前用过的命令

历史命令默认保存文件：~/.bash_history
history [选项] [历史命令保存文件]
        -c  清空历史命令（没必要）
        -w  把缓存中的历史命令写入历史命令保存文件
[]表示可以省略        
```
- 默认保存1000条
    - 配置文件在`/etc/profile`，它是linux中重要的环境变量配置文件
    - `HISTSIZE=10000`设置历史命令保存10000条

**历史命令的调用**
- 常用：
    - 使用上下箭头
    - 先输入开头字串，使用`pagedown`和`pageup`键切换以字串开头的历史命令
- 不常用：
    - 使用`!n`重复执行第n条历史命令
    - 使用`!!`重复执行上一条命令
    - 使用`!字串`重复执行最后一条以该字串开头的命令

#### 命令与文件补全
按`Tab`键自动补全命令、文件或目录

### 3.2 命令别名与常用快捷键

#### 命令别名
- 定义别名`alias 别名='原命令'`
- 查询已定义的别名`alias`

##### 命令执行时的顺序

- 第一顺位执行用**绝对路径**或**相对路径执行**的命令
- 第二顺位执行**别名**
- 第三顺位执行**bash的内部命令**
- 第四顺位执行按照$PATH环境变量定义的目录查找顺序找到的**第一个命令**

##### 让别名永久生效

- 修改`~/.bashrc`文件，写入定义

##### 删除别名

`unalias 别名`

#### bash常用快捷键

快捷键|作用
------|----
ctrl+A|把光标移动到命令行开头
ctrl+E|把光标移动到命令行尾
*ctrl+C|强制终止
*ctrl+L|清屏
*ctrl+U|删除或剪切光标之前的命令
ctrl+K|删除或剪切光标之后的命令
*ctrl+Y|粘贴剪切的命令
*ctrl+R|在历史命令中搜索
*ctrl+D|退出当前终端
ctrl+Z|暂停并放入后台
ctrl+S|暂停屏幕输出
ctrl+Q|恢复屏幕输出

### 3.3 输入输出重定向

#### 标准输入输出
设备|设备文件名|文件描述符|类型
----|----------|----------|----
键盘|/dev/stdin|0|标准输入
显示器|/dev/stdout|1|标准输出
显示器|/dev/stderr|2|标准错误输出

#### 输出重定向
把命令的输出保存到文件当中

| 类型               | 符号              | 作用                                                         |
| ------------------ | ----------------- | :----------------------------------------------------------- |
| 标准重定向         | 命令 > 文件       | 以**覆盖**的方式，把命令的**正确**输出输出到指定的文件或设备当中 |
| 标准重定向         | 命令 >> 文件      | 以**追加**的方式，把命令的**正确**输出输出到指定的文件或设备当中 |
| 标准错误输出重定向 | 错误命令 2> 文件  | 以**覆盖**的方式，把命令的**错误**输出输出到指定的文件或设备当中 |
| 标准错误输出重定向 | 错误命令 2>> 文件 | 以**追加**的方式，把命令的**错误**输出输出到指定的文件或设备当中 |

- 把正确和错误输出命令分开没有意义
- 把正确和错误输出用一条命令输出的方法：

类型|符号|作用
----|----|----
正确输出和错误输出同时保存|命令 &> 文件|以**覆盖**的方式，把命令的**正确**输出和错误的输出输出到指定的文件或设备当中
-|命令 &>> 文件|以**追加**的方式，把命令的**正确**输出和**错误的输出输出到指定的文件或设备当中
*常见|命令 >> 文件1 2>> 文件2|以**追加**的方式，把命令的**正确**输出保存在文件1中，**错误**输出保存到文件2中

在shell脚本中把不必要的输出输出到垃圾箱：

`命令 &> /dev/null`

#### 输入重定向
从文件输入执行命令的参数

用得不多，一般只会在给源码包打补丁的时候用到

```bash
统计文本的信息：
wc [选项] < [文件名]
    -c  统计字节数
    -w  统计单词数
    -l  统计行数

直接执行wc
会要求继续输入文字，ctrl+D结束
wc会把输入的内容作为标准输入，统它们的行数、单词数、字符数信息

wc < 文件
把文件内容作为输入，统计行数、单词数、字符数信息
这里的 < 就是输入重定向
```

### 3.4 多命令顺序执行与管道符

#### 多命令顺序执行

多命令执行符|格式|作用
--|--|--
;|命令1; 命令2|多个命令之间没有任何逻辑联系
&&|命令1&&命令2|逻辑与，命令1正确执行，命令2才会执行
\|\||命令1\|\|命令2|逻辑或，命令1执行不正确，命令2才执行

**例子**：
- 磁盘拷贝命令`dd`
```bash
dd if=输入文件 of=输出文件 bs=字节数 count=个数
选项：
    if=输入文件     指定源文件或源设备
    of=输出文件     指定目标文件或目标设备
    bs=字节数       指定一次输入/输出多少字节
                   即把这些字节看做一个数据块
    count=个数      指定输入/输出多少个数据块
```
```bash
date ; dd if=/dev/zero of=/root/testfile bs=1K count=1024000 ; date
查看本机拷贝一个约1000M的文件需要多少时间
```
- 源码包安装`./configure && make && makeinstall`
- 判断命令是否正确`命令 && echo y || echo n`

#### 管道符
`命令1 | 命令2`

命令1的正确输出作为命令2的操作对象

常见于查找命令`grep`
- `tail /var/log/secure | grep -v refused`查询ssh安全日志，不查看被拦截的日志
- `netstat -an | grep ESTABLISHED`查看正在连接的网络

### 3.5 通配符与其他特殊符号

通配符  |作用
--      |--
?       |匹配一个任意字符
*|匹配0个或任意多个任意字符，也就是可以匹配任何内容
[]|匹配中括号中任意一个字符，例如[abc]表示匹配a或b或c
[-]|[a-z]，匹配任意一个小写字母
[^]|逻辑非，匹配不是中括内的一个字符。\[^0-9]匹配不是数字的字符

其他特殊符号

符号|作用
--|--
''|单引号，在单引号中所有的符号都没有特殊意义，都只是一个字符
""|双引号，在双引号中，$表示调用变量的值，` 反引号表示引用命令，\表示转义符，!表示执行历史的命令或者当做逻辑否定，其他符号没有特殊含义
``|反引号，反引号里的内容是系统命令，在bash中会先执行它
$()|和反引号一样，但是常用这个因为更清晰
#|在shell脚本中代表注释
$|用于调用变量的值
\ |转义符，在转义符后的特殊符号会失去特殊意义

- `echo "hello world!"`会报错，而`echo 'hello world!'`却不会，因为单引号中的！没有特殊意义
```bash
abc=`date`或abc=$(date)
echo $abc
会输出日期
```

## 4 bash的变量

### 4.1 用户自定义变量

#### 什么是变量

​		变量是**计算机内存的单元**，可以**临时存储数据**，其中存放的数据**可以改变**。程序可以在变量中临时存取数据，可以让数据在程序中跨行传递，每个变量都有一个名字，通过这个名字就可以获取它的数据。使用变量可以保存有用的信息，使系统获知用户的相关设置，变量也可以用于保存暂时信息。

#### 变量设置规则

- 变量名称可以由字母、数字和下划线组成，但是**不能以数字开头**
- 在bash中，变量默认类型都是**字符串型**，如果要进行数值运算，则**必须指定**变量类型为**数值型**
- 变量是用`=`连接值，等号左右**两侧不能有空格**
- 变量的值如果有空格，需要用`''`或`""`
- 在变量的值中，可以使用`\`转义符
- 如果需要增加变量的值，可以进行变量值的**叠加**。不过变量需要`"$变量名"`或`${变量名}`
- 可以把命令作为变量值，但命令需要被反引号``或$()包含
- 环境变量名建议大写，便于区分

#### 变量分类

- 用户自定义变量
- 环境变量：保存与系统操作环境相关的数据
- 位置参数变量：用来向脚本传递参数或数据，变量名不能自定义，变量作用是固定的
- 预定义变量：是bash中已经定义好的变量，变量名不能自定义，变量作用固定，位置参数变量也是一种预定义变量

#### 本地变量

- 变量定义`name="xyz"`

- 变量调用`echo $name`

- 变量叠加

  ```bash
  aa=123
  aa="$aa"456
  aa=${aa}789
  ```

- 变量查看`set`查看系统中的所有变量
- 变量删除`unset name`

### 4.2 环境变量

#### 环境变量是什么

​		用户自定义变量只在**当前的shell中生效**，而环境变量会在当前的shell和这个shell的子shell当中生效。如果把环境变量写入配置文件，那么这个环境变量就会在**所有的shell中生效**

#### 设置环境变量

```bash
申明变量
export 变量名=变量值
export 变量名

查询环境变量
env

删除变量
unset 变量名	
```

- 要启动子shell，直接输入新shell名，如`bash`即可

- 查看当前shell是否为子shell用`pstree`

#### 系统常见环境变量

- `PATH`：系统查找命令的路径，系统会在这些路径中去搜索命令程序文件，如`ls`

  ```bash
  echo $PATH
  /usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/usr/local/go/bin:/root/mygo/bin:/usr/local/vim/bin:/root/bin
  ```

  - PATH变量叠加`PATH="$PATH":/root/sh`或`PATH=${PATH}:/root/sh`
  - 也可以用`export PATH=$PATH:/root/sh`

- `PS1`：定义系统提示符的变量

  | 系统提示符 | 作用                            |
  | ---------- | ------------------------------- |
  | \d         | 显示日期，格式为”星期 月 日“    |
  | \h         | 显示简写主机名，默认是localhost |
  | \t         | 显示24小时制时间hh:mm:ss        |
  | \T         | 显示12小时制时间hh:mm:ss        |
  | \A         | 显示24小时制时间hh:mm           |
  | \u         | 显示当前用户名                  |
  | \w小写     | 显示当前所在目录的完整名称      |
  | \W大写     | 显示当前所在目录的最后一个目录  |
  | \\#        | 显示当前执行的第几个命令        |
  | \\$        | 提示符。root是#，普通用户是$    |

- 修改`PS1='[\u@\t \W]\$ '`

  ```
  修改结果为：
  [root@15:59:51 ~]# 
  ```

### 4.3 位置参数变量

| 位置参数变量 | 作用                                                         |
| :----------- | ------------------------------------------------------------ |
| $n           | n为数字，$0代表命令本身，$1-$9代表第一到第九个参数，十以上的参数需要用大括号括起来，如${10} |
| $*           | 代表命令行中所有的参数，$*把所有参数看成一个整体，在for循环遍历时，只会循环一次 |
| $@           | 也代表命令行中所有的参数，不过$@把所有参数区分对待，在for循环遍历时，会把参数一个一个取出 |
| $#           | 代表命令行中所有参数的个数                                   |

例子1：

```bash
#!/bin/bash
num1=$1
num2=$2
sum=$(($num1+$num2))
#或sum=$(($1+$2))
echo "sum is : $sum"
#将第一个参数和第二个参数相加，输出和
```

例子2：

```bash
#!/bin/bash
#$*和$@的区别

for i in "$*"
	do
		echo $i
	done
x=1
for j in "$@"
	do
		echo "$x : $j"
        x=$(($x+1))
    done

输入a b c d
结果为:
a b c d
1 : a
2 : b
3 : c
4 : d
```

### 4.4 预定义变量

| 预定义变量 | 作用                                                         |
| ---------- | ------------------------------------------------------------ |
| $?         | 上一个命令的返回状态，0表示上一个命令正确执行，非0则证明命令执行不正确。`&&`和`||`就是通过判断`$?`来判断命令是否正确执行 |
| $$         | 当前进程的进程号PID                                          |
| $!         | 后台运行的最后一个进程的进程号PID                            |

#### 接收键盘输入

```
read [选项] [变量名]
	 -p "提示信息"		在等待read输入时，输出提示信息
	 -t 秒数			 read命令会一直等待用户输入，使用此选项可以指定等待时间
	 -n 字符数			read命令只接收指定的字符数，就会执行
	 -s				  隐藏输入的数据，适用于机密信息的输入
```

例子：

```bash
#!/bin/bash

read -t 30 -p "name : " name
#30s内输入，显示提示信息
read -t 30 -s -p "age : " age
#30s内输入，输入内容会隐藏，显示提示信息
read -t 30 -n 1 -p "sex : [m/f] " sex
#30s内输入，输入一个字符就会执行，显示提示信息

echo -e "name : $name\nage : $age\nsex : $sex"
```

## 5 bash的运算符

### 5.1 数值运算与运算符

在shell中，变量默认是字符串类型，所以申明数值变量需要声明变量类型

#### declare声明变量类型

```shell
decalare [+/-][选项] 变量名
			-	给变量设定类型属性
			+	取消变量的类型属性
			-i	声明整数型变量
			-x	声明环境变量
			-p	查看指定变量的被声明类型
```

#### 数值运算方法

- 方法一：declare声明

```shell
aa=11
bb=22
declare -i cc=$aa+$bb
echo $cc
结果为33
```

- 方法二：expr或let数值运算工具

```shell
aa=11
bb=22
dd=$(expr $aa + $bb)
#$()表示执行expr命令
#注意+左右两侧必须有空格
echo $dd
结果为33
```

- 推荐方法三：`"$((运算式))"`或`"$[运算式]"`

```shell
aa=11
bb=22
ff=$(($aa+$bb))
gg=$[$aa+$bb]
echo $ff $gg
结果为33 33
```

#### 运算符

| 优先级 | 运算符                                             | 说明                           |
| ------ | -------------------------------------------------- | ------------------------------ |
| 13高   | -，+                                               | 负，正                         |
| 12     | ！，~                                              | 逻辑非，按位取反或补码         |
| 11     | *，/，%                                            | 乘，除，取余                   |
| 10     | +，-                                               | 加，减                         |
| 9      | <<，>>                                             | 按位左移，按位右移             |
| 8      | <=，>=，<，>                                       | 小于等于，大于等于，小于，大于 |
| 7      | ==，!=                                             | 等于，不等于                   |
| 6      | &                                                  | 按位与                         |
| 5      | ^                                                  | 按位异或                       |
| 4      | \|                                                 | 按位或                         |
| 3      | &&                                                 | 逻辑与                         |
| 2      | \|\|                                               | 逻辑或                         |
| 1低    | =，+=，-=，*=，/=，%=，<br />&=，^=，\|=，<<=，>>= | 赋值、运算且赋值               |

### 5.2 变量测试与内容替换

| 变量置换方式 | 变量y没有设置               | 变量y为空                    | 变量y设置值       |
| ------------ | --------------------------- | ---------------------------- | ----------------- |
| x=${y-new}   | x=new                       | x为空                        | x=$y              |
| x=${y:-new}  | x=new                       | x=new                        | x=$y              |
| x=${y+new}   | x为空                       | x=new                        | x=new             |
| x=${y:+new}  | x为空                       | x为空                        | x=new             |
| x=${y=new}   | x=new<br />y=new            | x为空<br />y不变             | x=$y<br />y值不变 |
| x=${y:=new}  | x=new<br />y=new            | x=new<br />y=new             | x=$y<br />y值不变 |
| x=${y?new}   | new输出到<br />标准错误输出 | x为空                        | x=$y              |
| x=${y:?new}  | new输出到<br />标准错误输出 | 新值输出到<br />标准错误输出 | x=$y              |

- 例子1：测试`x=${y-新值}`

```shell
unset y
x=${y-new}
echo $x
结果为new
#因为y不存在，x=new

y=""
x=${y-new}
echo $x
结果为空
#因为y为空，x也为空

y=123
x=${y-new}
echo $x
结果为123
#因为y为123，x也为123
```

## 6 环境变量配置文件

### 6.1 环境变量配置文件简介

让环境变量永久生效的文件就是环境变量配置文件

#### source命令

`source 配置文件`或`. 配置文件` .后有空格

重载配置文件

#### 环境变量配置文件简介

环境变量配置文件中主要是定义对系统的操作环境生效的系统默认环境变量，比如PATH、HISTSIZE、PS1、HOSTNAME等

系统中的环境变量配置文件：

- `/etc/profile`
- `/etc/profiled/*.sh`
- `~/.bash_profile`
- `~/.bashrc`
- `/etc/bashrc`

`/etc`下的环境变量对每一个登录的用户都生效

### 6.2 环境变量配置文件作用

#### 环境变量配置文件启动流程

```
graph LR
A[/etc/profile]-->B["~/.bash_profile"]
B-->C["~/.bashrc"]
C-->D[/etc/bashrc]
D-->E[命令提示符]
A-->F[/etc/profile.d/*.sh]
D-->F
F-->G[/etc/profile.d/lang.sh]
G-->H[/etc/sysconfig/i18n]
```

#### 各个配置文件的作用

- `/etc/profile`的作用
  - USER变量：当前用户名
  - LOGNAME变量：当前登录用户名
  - MAIL变量：邮箱
  - PATH变量
  - HOSTNAME变量
  - HISTSIZE变量
  - umask
  - 调用`/etc/profile.d/*.sh`文件
    - `lang.sh-->~/.i18n`语言配置文件

- `~/.bash_profile`的作用
  - 判断`~/.bashrc`是否存在，如果存在就调用它
  - 在环境变量中加入`~/bin`

- `~/.bashrc`的作用
  - 定义系统别名`alias`
  - 调用下一个文件`etc/bashrc`

- `/etc/bashrc`的作用
  - 定义登录起始符PS1
  - 不是通过用户名密码登录的情况下
    - 定义PATH、umask
    - 调用`/etc/profile.d/*.sh`

#### 修改建议

- 不在/etc/profile中添加其他的内容
  - 要添加，写成脚本放在`/etc/profile.d/`下
- `/etc/`下的配置文件都是全局的，`~/`下的是用户自定义的
- 同一个环境变量，后面加载的文件会覆盖前面加载的文件
- 用户自定义环境变量通常写在`~/.bashrc`里
  - 最后加载不会被覆盖
  - 方便备份
- 修改完成后，记得`source 配置文件`或`. 配置文件`使生效

### 6.3 其他配置文件和登录信息

#### 注销时生效的环境变量配置文件

- `~/.bash_logout`
  - 默认为空，可以自定义退出登录后要执行的操作

#### 其他配置文件

- 历史文件保存目录`~/.bash_history`
  - 不建议清空
  - 明文密码可以手动删除
  - 是排错的重要历史文件
  - 黑客入侵肯定会清除操作记录，如果发现命令操作记录被清空，说明能已经被黑客光顾了

#### 登录信息

提醒登录注意事项，声明入侵法律责任

- 本地登录信息配置文件`/etc/issue`

| 转义符 | 作用                           |
| ------ | ------------------------------ |
| \d     | 显示当前系统日期               |
| \s     | 显示操作系统名称               |
| \l     | 显示登录终端号，常用           |
| \m     | 显示硬件体系结构，如i386、i686 |
| \n     | 显示主机名                     |
| \o     | 显示域名                       |
| \r     | 显示内核版本                   |
| \t     | 显示当前系统时间               |
| \u     | 显示当前登录用户序列号         |

- 远程登录信息配置文件`/etc/issue.net`
  - 转义符在`/etc/issue.net`中不能使用
  - 是否显示此信息，由ssh的配置文件`/etc/ssh/sshd_config`决定，加入`Banner /etc/issue.net`行才能显示，修改配置文件后要重启sshd服务

- 登陆后显示信息`/etc/motd`
  - 登录成功后就会显示，无论是本地还是远程
  - 默认为空，直接输入即可